---
title: "Short, Long, and Hybrid Genome Assembly"
author: "Prof. Harbert & Alex Baryiames"
date: "Meeting 18?"
output: 
  html_document:
    theme: united
    highlight: tango
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 4
  
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(root.dir = '~/BIO331/hybrid')
```

# Scaling Up

Assembling the SARS-CoV-2 virus genome was a good warm-up to get familiar with some of the tools for working with whole genome sequence data. Now we will scale up our analyses and try some new software for building somewhat larger bacterial genomes.

The larger genome being targeted here (~5 million bp) is going to be more complicated to assemble than the SARS-CoV-2 29kb genome. Here we will test assembling this genome with only short read Illumina data, long read Nanopore data, and a hybrid assembly using both long and short reads. In general, short read technology is more accurate, but longer reads help us resolve particularly tangled portions of the graph and make for better (more complete) assemblies.


# New data:

Raw bacterial (*Klebsiella pneumoneae*) whole genome data from Illumina and Nanopore sequencing experiments: 

https://www.ncbi.nlm.nih.gov/sra/?term=SAMEA3357010


```{bash, eval=F, message=F, cache=T}
mkdir hybrid_assemble
cd hybrid_assemble
mkdir data
#set number of threads to use for parallelization
nthreads=8
#set variables pointing to the SRA run ID for 
#nanopore data
nanoraw="SRR5665597"
#illumina short read data
shortraw="ERR1023775"

fasterq-dump -e $nthreads -O data $nanoraw
fasterq-dump -e $nthreads --split-files -O data $shortraw

```

The ERR1023775 data is the *short-read* dataset. Check the data quality with fastqc.

```{bash, eval = F, message=F, cache=T}
fastqc -t $nthreads data/$shortraw* 
```

The SRR5665597 data is from a Nanopore sequencing experiment. Expect these results to look *different* because Nanopore data have a lower per base accuracy and variable read lengths.

```{bash, eval=F, message=F, cache=T}
fastqc -t $nthreads --nano data/$nanoraw*
```

How do these data look?


# Unicycler

Unicycler is a program that is specifically designed for the assembly of bacterial genomes from short-read (Illumina) and/or long read (Nanopore/PacBio) raw data. 

The Unicycler GitHub [README](https://github.com/rrwick/Unicycler#background) has an EXCELLENT demonstration of how it deals with de Bruijn graph complexities.

## Install Unicycler

Crap, we finally have to use anaconda...

```{bash, eval=F}
module load miniconda
conda create -y --name py368 python==3.6.8
conda install -f -y -q --name py33 -c conda-forge --file requirements.txt
conda activate py368
conda install -c bioconda unicycler
#conda deactivate 
```

## Running Unicycler: Illumina Only


```{bash, eval=F, message=F, cache=T}
#Illumina only Assembly 
unicycler  -1 data/$shortraw\_1.fastq -2 data/$shortraw\_2.fastq -o unicycler_short --threads $nthreads
```


Running Unicycler: Nanopore long reads only

```{bash, eval=F, message=F, cache=T}
#Long read assembly
unicycler -l data/$nanoraw.fastq -o unicycler_long --threads $nthreads
```

Running Unicycler: Hybrid assembly (Short + Long to resolve tangled graph)

```{bash, eval=F, message=F, cache=T}
#Hybrid Assembly 
unicycler -1 data/$shortraw\_1.fastq -2 data/$shortraw\_2.fastq -l data/$nanoraw.fastq -o unicycler_hybrid --threads $nthreads
```

# Visualize in Quast

```{bash, eval=F}
assemblyILL=unicycler_illumina/assembly.fasta
assemblyNANO=unicycler_long/assembly.fasta
assemblyHYB=unicycler_hybrid/assembly.fasta
quast.py -o quast_hybrid --pe1 data/$shortraw\_1.fastq --pe2 data/$shortraw\_2.fastq --nanopore $nanoraw* --glimmer --threads $nthreads -m 1000 -l "illumina, nanopore, hybrid" $assemblyILL $assemblyNANO $assemblyHYB

```

Next class we will look at the quast output and discuss the pipeline and results.

[home](https://bio331.devbioinformatics.org)
