---
title: "Viewing your Genome Assembly"
author: "Prof. Harbert"
date: "Meeting 19"
output: 
  html_document:
    theme: united
    highlight: tango
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 4
  
---


```{r setup, include=FALSE}
library(reticulate)
use_python('/path/to/python') #EDIT
knitr::opts_chunk$set(echo = TRUE)
```

[home](https://bio331.devbioinformatics.org)

# Overview 

Today we will look at the genome assemblies we attempted last time. 

With remaining time this lesson will put together a reproducible Bash script to perform and visualize our genome assembly.

# Scripting: Putting together reproducible analyses

Anything that you can run by typing at the Unix command prompt (i.e., *most* bioinformatics software) can, and should, be written in a Bash script. This way you will be able to manage complex commands and workflows without worrying about mis-typing a command or getting things out of order. Also, you can automate your analysis; as soon as one part is done the next will start to run.

## Setting up your script

Open a new text file in RStudio (save with ".sh" file extension) and add:

```{bash, eval=F}
#!/bin/bash
#This is a comment
echo "This is a test"
ls -lh
```

Run the script. What is the output?

```{bash, eval=F}
bash ./pathto/shell_assembly_script.sh
```

## Script Organization

A good script is designed to be re-used. It does not matter how efficient your code is or if it is formatted formally. What makes a document like this useful to yourself and others is whether it can be understood. This means that you need to clearly provide the details of how to use the script and what it is doing along the way.

Open your script again and add comment lines (Start each line with '#') to the top with the following information about your project:

+ Your name
+ Current Term/Year
+ Citation of software you are using (at least version #s)
+ Source of data (ID number and/or URL)
+ A list of required programs

## Setting Variables

A good starting point of any script is to set up bash variables with the path to your data (and eventually any reference data).

You set a bash variable like this: (try it on the command line first)

```{bash, eval=F}
var='value'
```

And call as:

```{bash, eval=F}
echo $var
```

For example, you may want to add the path to your data (e.g., put it in your project directory) to the top of the script

```{bash, eval=F}
datapath='./data'
#then check it with:
echo $datapath
#and try and use it in a command:
ls -lh $datapath
```

## Testing

As you work on your script and add commands it is usually a good idea to test frequently.

From the terminal you can run your script as:

```{bash, eval=F}
bash ./pathto/shell_assembly_script.sh
```

## Adding programs

Add variables to the reads files and run the genome assembly of your choice. 

e.g.,

```{bash, eval=F}
reads1=data/unmapped.R1.fq
reads2=data/unmapped.R2.fq
dirout=dirMEGAHIT
megahit -t 8 -1 $reads1 -2 $reads2 -o $dirout

```

## Submit to your Git repository

Don't forget to *commit* and *push* this code to your code repository for the class. (*Make sure you are in your active RStudio project and save the code file there*)

[GitHub in RStudio guide](https://youtu.be/MdmnE3AnkQE)


# First Look: Assessment of Genome Assembly

Once you have contigs the  challenge becomes viewing the assembly and understanding how well this characterizes the genome.

Today we will be exploring some of the tools for visualizing and improving upon our Nanopore assemblies.

## Quast: Genome stats and visualization

[More notes on genome assembly and Quast here](https://astrobiomike.github.io/genomics/de_novo_assembly#quast)

One very useful tool for examining genome statistics is Quast. This helps visualize how much and which parts of the genome our contigs cover.

Install Quast from SourceForge repository: http://quast.sourceforge.net/docs/manual.html#sec1

```{bash, eval=F}
cd ~
mkdir src
cd src
wget https://downloads.sourceforge.net/project/quast/quast-5.0.2.tar.gz
tar -xzf quast-5.0.2.tar.gz
mv quast-5.0.2 quast
cd quast
./install.sh
cd ..
cd ..
```

Next edit your ~/.bashrc file to provide your environment with the path to Quast so you won't have to worry about that in the future.

```{bash, eval=F}
nano ~/.bashrc

#add a line at the END of the file with :
export PATH=$PATH:~/src/quast

#close with Ctrl+x and answer Y to save

source ~/.bashrc
```

Now run quast. With this command quast will:

+ Find contigs in each of our assemblys of length > 1000 bp
+ Align reads to these contigs and calculate coverage
+ Provide basic assembly statistics (e.g, [N50](https://en.wikipedia.org/wiki/N50,_L50,_and_related_statistics))
+ Predict genes with glimmer (http://ccb.jhu.edu/software/glimmer/index.shtml)


```{bash, eval=F}
assemblyMH=dirMEGAHIT/final.contigs.fa
assemblySPADES=spades_output/contigs.fasta
assemblyVELVET=dirVelvet/contigs.fa
reads1=data/unmapped.R1.fq
reads2=data/unmapped.R2.fq

quast.py -o quast_output --pe1 data/unmapped.R1.fq --pe2 data/unmapped.R1.fq --glimmer -t 4 -m 1000 -l "MEGAHIT, METASPADES, VELVET" $assemblyMH $assemblySPADES $assemblyVELVET

```


Look at the files in the 'quast_output' folder. Open in browser 'report.html', 'icarus_viewers/contig_size_viewer.html'

Now, we also benefit from being able to check our work. These assemblies *should* be similar to the reference genome. Let's use quast to compare with a known assembly:

```{bash, eval=F}
curl -o 'Wuhan-Hu1.fasta' 'https://www.ncbi.nlm.nih.gov/sviewer/viewer.cgi?tool=portal&save=file&log$=seqview&db=nuccore&report=fasta&id=1798174254&extrafeat=null&conwithfeat=on&hide-cdd=on'

ref=Wuhan-Hu1.fasta
quast.py -R $ref -o quast_wRef --pe1 data/unmapped.R1.fq --pe2 data/unmapped.R1.fq --glimmer -t 4 -m 1000 -l "MEGAHIT, METASPADES, VELVET" $assemblyMH $assemblySPADES $assemblyVELVET

```

# After Class:

Work on developing a genome assembly script that runs fastqc, assembly with metaSPAdes and MEGAHIT, and visualizes the resulting assemblies with Quast. We will workshopt these scripts next class.

[home](https://bio331.devbioinformatics.org)

